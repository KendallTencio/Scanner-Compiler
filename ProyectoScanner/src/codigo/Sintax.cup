package codigo;

import java_cup.runtime.Symbol;
import java.util.ArrayList;

parser code
{:
    public static ArrayList<Symbol> errores = new ArrayList<Symbol>();
    public static boolean fatalError = false;
    public static boolean specError = false;
    public static Symbol fatalErrorSym;
    public static String specErrorDetail = "";

    public void syntax_error(Symbol s){
        errores.add(s);
    }

    public void unrecovered_syntax_error(Symbol s){
        System.err.println("Error no recuperable captado");
        fatalError = true;
        fatalErrorSym = s;
    }

    public static void informar_Error_Especifico(String tipoError){
        String specErrorStr = "ERROR: "+tipoError;//+". Línea: "+specErrorSym.right+". Columna: "+specErrorSym.left;
        specErrorDetail = specErrorStr;
        specError = true;

        System.err.println(specErrorStr);
    }
:};

terminal Version, Reservadas, Operador, Transac, Units, Identificador, Literal, Address, As, Bool, Break,
         Byte, Bytes, Constructor, Continue, Contract, Delete, Do, Else, Enum, For, From, Function,
         Hex, If, Import, Int, Internal, Mapping, Modifier, Payable, Pragma, Private, Public, Return,
         Returns, Solidity, String, Struct, This, True, Ufixed, Uint, Var, View, While, Pipe, ShiftLeft,
         ShiftRight, DobleAsterisco, Coma, PuntoComa, Punto, ParenCuadAbre, ParenCuadCierra, SignoPregunta,
         DosPuntos, LlaveAbre, LlaveCierra, Ampersand, Elevar, Virgulilla, Suma, Resta, Mult, Div, Mod,
         ParentAbre, ParentCierre, Op_Booleano, Op_relacional, Not, Op_atribucion, Op_Incremental, IntValue, UintValue, BytesValue,
         ERROR_NotacionCientifica, ERROR_Identificador, ERROR_Comentario, ERROR_LiteralCero,ERROR;
non terminal INICIO, INICIODOS, BLOQUE_SENTENCIA, SENTENCIA, LISTA_SENTENCIA, PARTE_SENTENCIA; 
non terminal SENTENCIA_IF, SENTENCIA_ELSE, SENTENCIA_WHILE, SENTENCIA_DOWHILE, SENTENCIA_FOR, SENTENCIA_TERNARIA;
non terminal EXPRESION_BOOLEANA, EXPRECION_ARITMETICA, EXPRESION_PRIMARIA, EXPRESION_INCREMENTAL;
non terminal EXPRESION_TUPLA_PPARENTESIS, EXPRESION_TUPLA_PPARENTESIS_PRIMA;
non terminal STRUCTDEF, STRUCTCONTEN, DECLARVARIABLE, DECLARVARDOS;
non terminal FUNCIONDEF, FUNCIONATRIB, FUNATRIBDOS ,MODIFICADORES, FUNCIONRETURNS,FUNCIONCONTEN, FUNCIONCUERPO, SENTENCIA_RETURN;
non terminal FUNCCALL, PARAMFUNC, ASIGVARIABLE;
non terminal TYPENAME, ELEMENTARYTYPENAME, ARRAYDECLAR, ACCESSMOD;
non terminal ENUMDEF, ENUMCONTEN, ENUMLIST, ENUMVALUE;
non terminal CONTRACTDEF, CONTRACTPART, CONTRACTPART1, CONTRACTPART2, CONTRACTPART3;
non terminal LISTA_SENTENCIAPRIMA;

precedence left Suma, Resta;
precedence left Mult, Div, Mod;


start with INICIO;

/*
contract hola{
 function ccc(string y){
   int x = 3;
   return e;
 }
};

contract hola{
 function ccc(string y){
   int x = 3;

  while(true){
        string yy = "hola";
         for(int x = 2; x < 10 ; --x){
             int x = x;
             if(Marco){
                 break;
             }
            else{
                string Gilgamesh = "Are u winning son?";
             }
             break;
         }
       continue;
   }
   return x;
 }
};

*/

INICIO ::= Pragma Solidity Version PuntoComa INICIODOS;

INICIODOS ::= STRUCTDEF INICIODOS                        
            //| FUNCCALL INICIODOS
            | CONTRACTDEF INICIODOS 
            | ENUMDEF INICIODOS
            | {: RESULT = null; :};

//LISTA_SENTENCIA ::= SENTENCIA LISTA_SENTENCIAPRIMA;
LISTA_SENTENCIAPRIMA ::= SENTENCIA LISTA_SENTENCIAPRIMA | {: RESULT = null; :};

SENTENCIA ::= SENTENCIA_IF
            | SENTENCIA_WHILE 
            | SENTENCIA_DOWHILE PuntoComa
            | SENTENCIA_FOR 
            | SENTENCIA_RETURN
            | SENTENCIA_TERNARIA
            | DECLARVARIABLE
            | ASIGVARIABLE
            | FUNCCALL                       
            | Break PuntoComa
            | Continue PuntoComa
            | error PuntoComa
            | error LlaveCierra; 

SENTENCIA_IF ::= If ParentAbre EXPRESION_BOOLEANA ParentCierre LlaveAbre LISTA_SENTENCIAPRIMA LlaveCierra
               | If ParentAbre EXPRESION_BOOLEANA ParentCierre LlaveAbre LISTA_SENTENCIAPRIMA LlaveCierra SENTENCIA_ELSE | If LlaveAbre EXPRESION_BOOLEANA LlaveCierra LlaveAbre LISTA_SENTENCIAPRIMA LlaveCierra {:Sintax.informar_Error_Especifico("ERROR: If con llaves");:};
SENTENCIA_ELSE ::= Else LlaveAbre LISTA_SENTENCIAPRIMA LlaveCierra;
    
SENTENCIA_WHILE ::= While ParentAbre EXPRESION_BOOLEANA ParentCierre LlaveAbre LISTA_SENTENCIAPRIMA LlaveCierra;
SENTENCIA_DOWHILE ::= Do LlaveAbre LISTA_SENTENCIAPRIMA LlaveCierra While ParentAbre EXPRESION_BOOLEANA ParentCierre;
SENTENCIA_FOR ::= For ParentAbre DECLARVARIABLE EXPRESION_BOOLEANA PuntoComa EXPRESION_INCREMENTAL ParentCierre LlaveAbre LISTA_SENTENCIAPRIMA LlaveCierra;
SENTENCIA_TERNARIA ::= EXPRESION_BOOLEANA SignoPregunta EXPRESION_PRIMARIA DosPuntos EXPRESION_PRIMARIA PuntoComa;

EXPRESION_BOOLEANA ::= Op_Booleano
                    | Not EXPRESION_BOOLEANA
                    | Not ParentAbre EXPRESION_BOOLEANA ParentCierre 
                    | EXPRESION_PRIMARIA Op_relacional EXPRESION_PRIMARIA
                    | EXPRESION_PRIMARIA Op_relacional ParentAbre EXPRESION_BOOLEANA ParentCierre
                    | ParentAbre EXPRESION_BOOLEANA ParentCierre Op_relacional EXPRESION_PRIMARIA
                    | Identificador;

EXPRESION_PRIMARIA ::= EXPRECION_ARITMETICA
                    | Identificador;

EXPRECION_ARITMETICA ::= EXPRECION_ARITMETICA Suma EXPRECION_ARITMETICA
                    | EXPRECION_ARITMETICA Resta EXPRECION_ARITMETICA
                    | EXPRECION_ARITMETICA Mult EXPRECION_ARITMETICA
                    | EXPRECION_ARITMETICA Div EXPRECION_ARITMETICA
                    | EXPRECION_ARITMETICA Mod EXPRECION_ARITMETICA
                    | Resta EXPRECION_ARITMETICA
                    | ParentAbre EXPRECION_ARITMETICA ParentCierre
                    | Literal;

EXPRESION_INCREMENTAL ::= Op_Incremental Identificador
                        | Identificador Op_Incremental;

STRUCTDEF ::= Struct Identificador STRUCTCONTEN;
STRUCTCONTEN ::= LlaveAbre DECLARVARIABLE LlaveCierra PuntoComa;

DECLARVARIABLE ::= TYPENAME ACCESSMOD Identificador PuntoComa | TYPENAME ACCESSMOD Identificador Op_atribucion Literal PuntoComa | TYPENAME ACCESSMOD Identificador Op_atribucion Identificador PuntoComa | ARRAYDECLAR;
ARRAYDECLAR ::= TYPENAME ParenCuadAbre ParenCuadCierra Identificador PuntoComa | TYPENAME ParenCuadAbre ParenCuadCierra Identificador Op_atribucion Literal PuntoComa | TYPENAME ParenCuadAbre ParenCuadCierra Identificador Op_atribucion Identificador PuntoComa;

ASIGVARIABLE ::= Identificador Op_atribucion Literal PuntoComa | Identificador Op_atribucion Identificador PuntoComa;

ACCESSMOD ::= Private | Public | error PuntoComa | {: RESULT = null; :};

CONTRACTDEF ::= Contract Identificador LlaveAbre CONTRACTPART LlaveCierra PuntoComa;
CONTRACTPART ::= ENUMDEF CONTRACTPART | CONTRACTPART1 | error PuntoComa | error LlaveCierra;
CONTRACTPART1 ::= DECLARVARIABLE CONTRACTPART1 | CONTRACTPART2; 
CONTRACTPART2 ::= STRUCTDEF CONTRACTPART2 | CONTRACTPART3;
CONTRACTPART3 ::= FUNCIONDEF CONTRACTPART3 | {: RESULT = null; :};

ENUMDEF ::= Enum Identificador ENUMCONTEN;
ENUMCONTEN ::= LlaveAbre Identificador ENUMLIST LlaveCierra;
ENUMLIST ::= Coma ENUMVALUE | error LlaveCierra | error PuntoComa | {: RESULT = null; :};
ENUMVALUE ::= Identificador ENUMLIST;

FUNCIONDEF ::= Function Identificador FUNCIONATRIB MODIFICADORES FUNCIONRETURNS FUNCIONCONTEN;

FUNCIONATRIB ::= ParentAbre TYPENAME Identificador FUNATRIBDOS;
FUNATRIBDOS ::= Coma TYPENAME Identificador FUNATRIBDOS | ParentCierre;

MODIFICADORES ::= Payable | Private | Public | Internal | {: RESULT = null; :};
FUNCIONRETURNS ::= Returns FUNCIONATRIB | {: RESULT = null; :};
FUNCIONCONTEN ::= LlaveAbre LISTA_SENTENCIAPRIMA LlaveCierra | error LlaveCierra;

SENTENCIA_RETURN ::= Return Identificador PuntoComa | Return Identificador {: Sintax.informar_Error_Especifico("Return de función sin punto y coma"); :};

PARAMFUNC ::= TYPENAME Identificador;
TYPENAME ::= ELEMENTARYTYPENAME;

ELEMENTARYTYPENAME ::= Bool | Byte | Bytes | Address | Int | String | Ufixed | Uint;

FUNCCALL  ::= Identificador ParentAbre PARAMFUNC ParentCierre PuntoComa;

