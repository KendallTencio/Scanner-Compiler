package codigo;

import java_cup.runtime.Symbol;
import java.util.ArrayList;

parser code
{:
    public static ArrayList<Symbol> errores = new ArrayList<Symbol>();
    public static ArrayList<String> erroresEspec = new ArrayList<String>();
    public static boolean fatalError = false;
    public static boolean specError = false;
    public static Symbol fatalErrorSym;
    public static String specErrorDetail = "";

    public void syntax_error(Symbol s){
        errores.add(s);
    }

    public void unrecovered_syntax_error(Symbol s){
        System.err.println("Error no recuperable captado");
        fatalError = true;
        fatalErrorSym = s;
    }

    public static void informar_Error_Especifico(String tipoError){
        String specErrorStr = "ERROR: "+tipoError;
        specErrorDetail = specErrorStr;
        erroresEspec.add(specErrorStr);
        specError = true;

        System.err.println(specErrorStr);
    }
:};

terminal Version, Reservadas, Operador, Transac, Units, Identificador, Literal, Address, As, Bool, Break,
         Byte, Bytes, Constructor, Continue, Contract, Delete, Do, Else, Enum, For, From, Function,
         Hex, If, Import, Int, Internal, Mapping, Modifier, Payable, Pragma, Private, Public, Return,
         Returns, Solidity, String, Struct, This, True, Ufixed, Uint, Var, View, While, Pipe, ShiftLeft,
         ShiftRight, DobleAsterisco, Coma, PuntoComa, Punto, ParenCuadAbre, ParenCuadCierra, SignoPregunta,
         DosPuntos, LlaveAbre, LlaveCierra, Ampersand, Elevar, Virgulilla, Suma, Resta, Mult, Div, Mod,
         ParentAbre, ParentCierre, Op_Booleano, Op_relacional, Not, Op_atribucion, Op_Incremental, IntValue, UintValue, BytesValue,
         ERROR_NotacionCientifica, ERROR_Identificador, ERROR_Comentario, ERROR_LiteralCero,ERROR;
non terminal INICIO, INICIODOS, BLOQUE_SENTENCIA, SENTENCIA, LISTA_SENTENCIA, PARTE_SENTENCIA; 
non terminal SENTENCIA_IF, SENTENCIA_ELSE, SENTENCIA_WHILE, SENTENCIA_DOWHILE, SENTENCIA_FOR, SENTENCIA_TERNARIA;
non terminal EXPRESION_BOOLEANA_PRIMA, EXPRESION_BOOLEANA, EXPRESION_ARITMETICA, EXPRESION_INCREMENTAL, EXPRESION;
non terminal EXPRESION_TUPLA_PPARENTESIS, EXPRESION_TUPLA_PPARENTESIS_PRIMA;
non terminal STRUCTDEF, STRUCTCONTEN, DECLARVARIABLE, DECLARVARDOS, PARAMFUNCFILA;
non terminal FUNCIONDEF, FUNCIONATRIB, FUNATRIBDOS ,MODIFICADORES, FUNCIONRETURNS,FUNCIONCONTEN, FUNCIONCUERPO, SENTENCIA_RETURN;
non terminal FUNCCALL, PARAMFUNC, ASIGVARIABLE, ASIGVARIABLEFUN , DECLARVARIABLEFILA, ARRAYDECLARFILA;
non terminal TYPENAME, ELEMENTARYTYPENAME, ARRAYDECLAR, ACCESSMOD;
non terminal ENUMDEF, ENUMCONTEN, ENUMLIST, ENUMVALUE;
non terminal CONTRACTDEF, CONTRACTPART, CONTRACTPART1, CONTRACTPART2, CONTRACTPART3;
non terminal LISTA_SENTENCIAPRIMA;

precedence left Suma, Resta;
precedence left Mult, Div, Mod;

precedence left Op_relacional;
precedence left Punto;

start with INICIO;

/*
contract hola{
 function ccc(string y){
   int x = 3;
   return e;
 }
};

contract hola{
 function ccc(string y){
   int x = 3;

  while(true){
        string yy = "hola";
         for(int x = 2; x < 10 ; --x){
             int x = x;
             if(Marco){
                 break;
             }
            else{
                string Gilgamesh = "Are u winning son?";
             }
             break;
         }
       continue;
   }
   return x;
 }
};

*/

INICIO ::= Pragma Solidity Version PuntoComa INICIODOS;

INICIODOS ::= STRUCTDEF INICIODOS                        
            //| FUNCCALL INICIODOS
            | CONTRACTDEF INICIODOS 
            | ENUMDEF INICIODOS
            | DECLARVARIABLE INICIODOS {: Sintax.informar_Error_Especifico("Declaración fuera de función"); :}
            | {: RESULT = null; :};

LISTA_SENTENCIAPRIMA ::= SENTENCIA LISTA_SENTENCIAPRIMA | {: RESULT = null; :};

SENTENCIA ::= SENTENCIA_IF
            | SENTENCIA_WHILE 
            | SENTENCIA_DOWHILE PuntoComa
            | SENTENCIA_FOR 
            | SENTENCIA_RETURN
            | SENTENCIA_TERNARIA
            | DECLARVARIABLE PuntoComa
            | ASIGVARIABLE PuntoComa
            | FUNCCALL PuntoComa
            | Break PuntoComa
            | Continue PuntoComa
            | error PuntoComa
            | error LlaveCierra; 

SENTENCIA_IF ::= If ParentAbre EXPRESION ParentCierre LlaveAbre LISTA_SENTENCIAPRIMA LlaveCierra
               | If ParentAbre EXPRESION ParentCierre LlaveAbre LISTA_SENTENCIAPRIMA LlaveCierra SENTENCIA_ELSE; 
SENTENCIA_ELSE ::= Else LlaveAbre LISTA_SENTENCIAPRIMA LlaveCierra;
    
SENTENCIA_WHILE ::= While ParentAbre EXPRESION_BOOLEANA ParentCierre LlaveAbre LISTA_SENTENCIAPRIMA LlaveCierra;
SENTENCIA_DOWHILE ::= Do LlaveAbre LISTA_SENTENCIAPRIMA LlaveCierra While ParentAbre EXPRESION_BOOLEANA ParentCierre;
SENTENCIA_FOR ::= For ParentAbre DECLARVARIABLE EXPRESION_BOOLEANA PuntoComa EXPRESION_INCREMENTAL ParentCierre LlaveAbre LISTA_SENTENCIAPRIMA LlaveCierra;
SENTENCIA_TERNARIA ::= EXPRESION_BOOLEANA SignoPregunta EXPRESION_ARITMETICA DosPuntos EXPRESION_ARITMETICA PuntoComa;

//EXPRESION ::= EXPRESION_BOOLEANA | EXPRESION_ARITMETICA | EXPRESION_INCREMENTAL;

EXPRESION ::=         EXPRESION Op_relacional EXPRESION
                    | ParentAbre EXPRESION ParentCierre
                    | Not EXPRESION
                    | Identificador
                    | Op_Booleano
                    | EXPRESION Suma EXPRESION
                    | EXPRESION Resta EXPRESION
                    | EXPRESION Mult EXPRESION
                    | EXPRESION Div EXPRESION
                    | EXPRESION Mod EXPRESION
                    | Resta EXPRESION
                    | EXPRESION_INCREMENTAL
                    | FUNCCALL
                    | This Punto EXPRESION
                    | EXPRESION Punto EXPRESION
                    | Literal;


/*
EXPRESION_BOOLEANA ::= Op_Booleano
                    | Not EXPRESION_BOOLEANA
                    | Not ParentAbre EXPRESION_BOOLEANA ParentCierre 
                    | EXPRESION_ARITMETICA Op_relacional EXPRESION_ARITMETICA
                    | EXPRESION_ARITMETICA Op_relacional ParentAbre EXPRESION_BOOLEANA ParentCierre
                    | ParentAbre EXPRESION_BOOLEANA ParentCierre Op_relacional EXPRESION_ARITMETICA
                    | Identificador;

EXPRESION_ARITMETICA ::= EXPRESION_ARITMETICA Suma EXPRESION_ARITMETICA
                    | EXPRESION_ARITMETICA Resta EXPRESION_ARITMETICA
                    | EXPRESION_ARITMETICA Mult EXPRESION_ARITMETICA
                    | EXPRESION_ARITMETICA Div EXPRESION_ARITMETICA
                    | EXPRESION_ARITMETICA Mod EXPRESION_ARITMETICA
                    | Resta EXPRESION_ARITMETICA
                    | ParentAbre EXPRESION_ARITMETICA ParentCierre
                    | EXPRESION_INCREMENTAL
                    | Literal;
*/
EXPRESION_INCREMENTAL ::= Op_Incremental Identificador
                        | Identificador Op_Incremental;

STRUCTDEF ::= Struct Identificador STRUCTCONTEN;
STRUCTCONTEN ::= LlaveAbre DECLARVARIABLE LlaveCierra PuntoComa;

DECLARVARIABLE ::= TYPENAME ACCESSMOD Identificador DECLARVARIABLEFILA | TYPENAME ACCESSMOD Identificador Op_atribucion EXPRESION | ARRAYDECLAR;
DECLARVARIABLEFILA ::= Coma Identificador DECLARVARIABLEFILA | {: RESULT = null; :};
ARRAYDECLAR ::= TYPENAME ParenCuadAbre ParenCuadCierra Identificador ARRAYDECLARFILA | TYPENAME ParenCuadAbre ParenCuadCierra Identificador Op_atribucion EXPRESION;
ARRAYDECLARFILA ::= Coma Identificador ARRAYDECLARFILA |{: RESULT = null; :};

ASIGVARIABLE ::= Identificador Op_atribucion EXPRESION;
ASIGVARIABLEFUN ::= EXPRESION Op_atribucion EXPRESION;

ACCESSMOD ::= Private | Public | error PuntoComa | {: RESULT = null; :};

CONTRACTDEF ::= Contract Identificador LlaveAbre CONTRACTPART LlaveCierra | error LlaveCierra;
CONTRACTPART ::= ENUMDEF CONTRACTPART | CONTRACTPART1;
CONTRACTPART1 ::= DECLARVARIABLE PuntoComa CONTRACTPART1 | ASIGVARIABLE PuntoComa CONTRACTPART1 |CONTRACTPART2; 
CONTRACTPART2 ::= STRUCTDEF CONTRACTPART2 | CONTRACTPART3;
CONTRACTPART3 ::= FUNCIONDEF CONTRACTPART3 | {: RESULT = null; :};

ENUMDEF ::= Enum Identificador ENUMCONTEN;
ENUMCONTEN ::= LlaveAbre Identificador ENUMLIST LlaveCierra | error LlaveCierra;
ENUMLIST ::= Coma ENUMVALUE | {: RESULT = null; :};
ENUMVALUE ::= Identificador ENUMLIST;

FUNCIONDEF ::= Function Identificador FUNCIONATRIB MODIFICADORES FUNCIONRETURNS FUNCIONCONTEN;

FUNCIONATRIB ::= ParentAbre TYPENAME Identificador FUNATRIBDOS;
FUNATRIBDOS ::= Coma TYPENAME Identificador FUNATRIBDOS | ParentCierre;

MODIFICADORES ::= Payable | Private | Public | Internal | {: RESULT = null; :};
FUNCIONRETURNS ::= Returns FUNCIONATRIB | {: RESULT = null; :};
FUNCIONCONTEN ::= LlaveAbre LISTA_SENTENCIAPRIMA LlaveCierra | error LlaveCierra;

SENTENCIA_RETURN ::= Return Identificador PuntoComa | Return Identificador {: Sintax.informar_Error_Especifico("Return de función sin punto y coma"); :};

PARAMFUNC ::= EXPRESION PARAMFUNCFILA | ASIGVARIABLEFUN PARAMFUNCFILA | {: RESULT = null; :};
PARAMFUNCFILA ::= Coma EXPRESION PARAMFUNCFILA | Coma ASIGVARIABLEFUN PARAMFUNCFILA  | {: RESULT = null; :};
TYPENAME ::= ELEMENTARYTYPENAME;

ELEMENTARYTYPENAME ::= Bool | Byte | Bytes | Address | Int | String | Ufixed | Uint;

FUNCCALL  ::= Identificador ParentAbre PARAMFUNC ParentCierre | This ParentAbre PARAMFUNC ParentCierre;

